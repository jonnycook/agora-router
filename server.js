// Generated by CoffeeScript 1.7.1
(function() {
  var OPEN, WebSocketServer, addDownServer, app, bodyParser, downServers, env, express, gatewayMessage, removeDownServer, request, send, serverId, start, wss, _, _ref;

  _ref = require('ws'), WebSocketServer = _ref.Server, OPEN = _ref.OPEN;

  request = require('request');

  express = require('express');

  bodyParser = require('body-parser');

  env = require('./env');

  wss = new WebSocketServer({
    port: env.wssPort
  });

  _ = require('lodash');

  process.on('uncaughtException', function(err) {
    return console.log(err);
  });

  serverId = 1;

  app = express();

  app.use(bodyParser());

  downServers = {};

  addDownServer = function(gatewayServerId) {
    console.log('server down %s', gatewayServerId);
    return downServers[gatewayServerId] = true;
  };

  removeDownServer = function(gatewayServerId) {
    console.log('server up %s', gatewayServerId);
    return delete downServers[gatewayServerId];
  };

  gatewayMessage = function(userId, type, params, success, fail) {
    var gatewayServerId;
    if (fail == null) {
      fail = null;
    }
    gatewayServerId = env.gatewayForUser(userId);
    if (downServers[gatewayServerId]) {
      return typeof fail === "function" ? fail('down', gatewayServerId) : void 0;
    } else {
      return request({
        url: "http://" + env.gatewayServers[gatewayServerId] + "/" + type,
        method: 'post',
        form: params
      }, function(error, response, body) {
        if (error) {
          addDownServer(gatewayServerId);
          return typeof fail === "function" ? fail('down', gatewayServerId) : void 0;
        } else {
          return success(body, gatewayServerId);
        }
      });
    }
  };

  send = function(ws, message) {
    if (ws.readyState === OPEN) {
      return ws.send(message);
    } else {
      return console.log('WebSocket not open');
    }
  };

  start = function() {
    var socketsByClientId;
    console.log('started');
    app.listen(env.httpPort);
    app.post('/update', function(req, res) {
      var clientId, ws, _i, _len, _ref1;
      _ref1 = req.body.clientIds;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        clientId = _ref1[_i];
        ws = socketsByClientId[clientId];
        if (ws) {
          if (ws.readyState === OPEN) {
            send(ws, "u" + req.body.userId + "\t" + req.body.changes);
          } else {
            delete socketsByClientId[clientId];
          }
        }
      }
      return res.send('');
    });
    app.post('/sync', function(req, res) {
      var clientId, ws, _i, _len, _ref1;
      _ref1 = req.body.clientIds;
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        clientId = _ref1[_i];
        ws = socketsByClientId[clientId];
        if (ws) {
          if (ws.readyState === OPEN) {
            send(ws, "Y" + req.body.userId + "\t" + req.body.object + "\t" + req.body.data);
          } else {
            delete socketsByClientId[clientId];
          }
        }
      }
      return res.send('');
    });
    app.post('/gateway/started', function(req, res) {
      var clientId, ws;
      removeDownServer(req.body.serverId);
      for (clientId in socketsByClientId) {
        ws = socketsByClientId[clientId];
        send(ws, "." + req.body.serverId);
      }
      return res.send('ok');
    });
    socketsByClientId = {};
    return wss.on('connection', function(ws) {
      var clientId, onError, setClientId;
      clientId = null;
      onError = function(error, gatewayServerId) {
        return ws.send("," + gatewayServerId);
      };
      setClientId = function(c) {
        console.log('client id %s', c);
        clientId = c;
        return socketsByClientId[clientId] = ws;
      };
      ws.on('close', function() {
        var e, gatewayServer, _i, _len, _ref1;
        _ref1 = env.gatewayServers;
        for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
          gatewayServer = _ref1[_i];
          try {
            request({
              url: "http://" + gatewayServer + "/unsubscribeClient",
              method: 'post',
              form: {
                clientId: clientId
              }
            });
          } catch (_error) {
            e = _error;
            console.log('error');
          }
        }
        return delete socketsByClientId[clientId];
      });
      return ws.on('message', function(message) {
        var changes, count, done, i, key, messageType, number, object, params, parts, r, toRetrieve, type, updateToken, userId, _i, _ref1, _ref2, _ref3, _ref4, _ref5, _results;
        console.log('message: %s', message);
        messageType = message[0];
        message = message.substr(1);
        switch (messageType) {
          case 'm':
            _ref1 = message.split('\t'), number = _ref1[0], userId = _ref1[1], type = _ref1[2], params = _ref1[3];
            params = JSON.parse(params);
            params.clientId = clientId;
            params.userId = userId;
            return gatewayMessage(userId, type, params, (function(body) {
              return send(ws, "<" + number + "\t" + body);
            }), onError);
          case 'i':
            _ref2 = message.split('\t'), number = _ref2[0], clientId = _ref2[1], userId = _ref2[2];
            setClientId(clientId);
            return gatewayMessage(userId, 'init', {
              serverId: serverId,
              clientId: clientId,
              userId: userId
            }, function(body, gatewayServerId) {
              return send(ws, "<" + number + "\t" + gatewayServerId + "\t" + body);
            }, onError);
          case 'u':
            _ref3 = message.split('\t'), number = _ref3[0], updateToken = _ref3[1], userId = _ref3[2], changes = _ref3[3];
            return gatewayMessage(userId, 'update', {
              serverId: serverId,
              updateToken: updateToken,
              clientId: clientId,
              userId: userId,
              changes: changes
            }, function(body) {
              return send(ws, "<" + number + "\t" + body);
            }, onError);
          case 's':
            _ref4 = message.split('\t'), number = _ref4[0], userId = _ref4[1], object = _ref4[2], key = _ref4[3];
            return gatewayMessage(userId, 'subscribe', {
              serverId: serverId,
              clientId: clientId,
              userId: userId,
              object: object,
              key: key
            }, function(body, gatewayServerId) {
              return send(ws, "<" + number + "\t" + gatewayServerId + "\t" + userId + "\t" + object + "\t" + body);
            }, onError);
          case 'z':
            _ref5 = message.split('\t'), number = _ref5[0], userId = _ref5[1], object = _ref5[2];
            return gatewayMessage(userId, 'unsubscribe', {
              serverId: serverId,
              clientId: clientId,
              userId: userId,
              object: object
            }, function(body) {
              return send(ws, "<" + number + "\t" + userId + "\t" + object);
            }, onError);
          case 'r':
            parts = message.split('\t');
            number = parts[0];
            parts = parts.slice(1);
            count = parts.length / 2;
            done = 0;
            r = [];
            _results = [];
            for (i = _i = 0; 0 <= count ? _i < count : _i > count; i = 0 <= count ? ++_i : --_i) {
              userId = parts[i * 2];
              toRetrieve = parts[i * 2 + 1];
              _results.push((function(userId) {
                return gatewayMessage(userId, 'retrieve', {
                  serverId: serverId,
                  userId: userId,
                  clientId: clientId,
                  records: toRetrieve
                }, function(body) {
                  r.push(userId);
                  r.push(body);
                  if (++done === count) {
                    return send(ws, "<" + number + "\t" + (r.join('\t')));
                  }
                }, onError);
              })(userId));
            }
            return _results;
        }
      });
    });
  };

  env.init(function() {
    var count, gatewayServer, id, num, _ref1, _results;
    count = 0;
    num = _.size(env.gatewayServers);
    _ref1 = env.gatewayServers;
    _results = [];
    for (id in _ref1) {
      gatewayServer = _ref1[id];
      _results.push(request({
        url: "http://" + gatewayServer + "/port/started",
        method: 'post',
        form: {
          serverId: serverId
        }
      }, function(error) {
        if (error) {
          addDownServer(id);
        }
        if (++count === num) {
          return start();
        }
      }));
    }
    return _results;
  });

}).call(this);

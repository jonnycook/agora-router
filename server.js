// Generated by CoffeeScript 1.8.0
var OPEN, WebSocketServer, addDownServer, app, bodyParser, downServers, env, express, gatewayMessage, removeDownServer, request, send, serverId, start, wss, _, _ref,
  __slice = [].slice;

_ref = require('ws'), WebSocketServer = _ref.Server, OPEN = _ref.OPEN;

request = require('request');

express = require('express');

bodyParser = require('body-parser');

env = require('./env');

wss = new WebSocketServer({
  port: env.wssPort
});

_ = require('lodash');

process.on('uncaughtException', function(err) {
  return console.log(err);
});

serverId = 1;

app = express();

app.use(bodyParser());

downServers = {};

addDownServer = function(gatewayServerId) {
  console.log('server down %s', gatewayServerId);
  return downServers[gatewayServerId] = true;
};

removeDownServer = function(gatewayServerId) {
  console.log('server up %s', gatewayServerId);
  return delete downServers[gatewayServerId];
};

gatewayMessage = function(userId, type, params, success, fail) {
  var gatewayServerId, startTime;
  if (fail == null) {
    fail = null;
  }
  gatewayServerId = env.gatewayForUser(userId);
  if (downServers[gatewayServerId]) {
    return typeof fail === "function" ? fail('down', gatewayServerId) : void 0;
  } else {
    startTime = new Date().getTime();
    return request({
      url: "http://" + env.gatewayServers[gatewayServerId] + "/" + type,
      method: 'post',
      form: params
    }, function(error, response, body) {
      var duration, endTime;
      endTime = new Date().getTime();
      duration = (endTime - startTime) / 1000;
      if (error) {
        console.log("error: " + userId + " " + type + " (" + duration + ")");
        return typeof fail === "function" ? fail('down', gatewayServerId) : void 0;
      } else {
        console.log("request: " + userId + " " + type + " (" + duration + ")");
        return success(body, gatewayServerId);
      }
    });
  }
};

send = function(ws, message) {
  if (ws) {
    if (ws.readyState === OPEN) {
      return ws.send(message);
    } else {
      return console.log('WebSocket not open');
    }
  }
};

start = function() {
  var commandCbs, count, nextCommandId, nextNumber, socketsByClientId;
  console.log('started');
  app.listen(env.httpPort);
  app.post('/update', function(req, res) {
    var clientId, ws, _i, _len, _ref1;
    _ref1 = req.body.clientIds;
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      clientId = _ref1[_i];
      ws = socketsByClientId[clientId];
      if (ws) {
        if (ws.readyState === OPEN) {
          send(ws, "u" + req.body.userId + "\t" + req.body.changes);
        } else {
          delete socketsByClientId[clientId];
        }
      }
    }
    return res.send('');
  });
  app.post('/sync', function(req, res) {
    var clientId, ws, _i, _len, _ref1;
    _ref1 = req.body.clientIds;
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      clientId = _ref1[_i];
      ws = socketsByClientId[clientId];
      if (ws) {
        if (ws.readyState === OPEN) {
          send(ws, "Y" + req.body.userId + "\t" + req.body.object + "\t" + req.body.data);
        } else {
          delete socketsByClientId[clientId];
        }
      }
    }
    return res.send('');
  });
  app.post('/gateway/started', function(req, res) {
    var clientId, ws;
    for (clientId in socketsByClientId) {
      ws = socketsByClientId[clientId];
      send(ws, "." + req.body.serverId);
    }
    return res.send('ok');
  });
  nextCommandId = 0;
  commandCbs = {};
  app.get('/command', function(req, res) {
    var commandId, timeoutId, ws;
    console.log(req.query);
    ws = socketsByClientId[req.query.clientId];
    commandId = nextCommandId++;
    send(ws, "$" + commandId + "\t" + req.query.command);
    timeoutId = setTimeout((function() {
      if (commandCbs[commandId]) {
        res.send('timeout');
        return delete commandCbs[commandId];
      }
    }), 1000 * 15);
    return commandCbs[commandId] = function(response) {
      res.send(response);
      return delete commandCbs[commandId];
    };
  });
  app.get('/ping', function() {
    var clientId, ws, _results;
    _results = [];
    for (clientId in socketsByClientId) {
      ws = socketsByClientId[clientId];
      console.log("pinging " + clientId + "...");
      _results.push(ws.send("p" + clientId));
    }
    return _results;
  });
  socketsByClientId = {};
  count = 0;
  setInterval((function() {
    return console.log("count: " + count);
  }), 1000 * 60);
  nextNumber = 0;
  return wss.on('connection', function(ws) {
    var clientId, onError, setClientId, wsNumber;
    ++count;
    wsNumber = nextNumber++;
    console.log("[" + wsNumber + "] opened (" + count + ")");
    clientId = null;
    onError = function(error, gatewayServerId) {
      return ws.send("," + gatewayServerId);
    };
    setClientId = function(c) {
      console.log("[" + wsNumber + "] client id " + c);
      clientId = c;
      return socketsByClientId[clientId] = ws;
    };
    ws.on('close', function() {
      var e, gatewayServer, id, _ref1;
      --count;
      console.log("[" + wsNumber + "] closed (" + count + ")");
      _ref1 = env.gatewayServers;
      for (id in _ref1) {
        gatewayServer = _ref1[id];
        try {
          request({
            url: "http://" + gatewayServer + "/unsubscribeClient",
            method: 'post',
            form: {
              clientId: clientId,
              serverId: serverId
            }
          });
        } catch (_error) {
          e = _error;
          console.log('error');
        }
      }
      return delete socketsByClientId[clientId];
    });
    return ws.on('message', function(message) {
      var args, changes, commandId, done, i, key, messageType, number, object, params, parts, r, response, toRetrieve, type, updateToken, userId, _i, _ref1, _ref2, _ref3, _ref4, _ref5, _ref6, _ref7, _results;
      console.log("[" + wsNumber + "] message: " + message);
      messageType = message[0];
      message = message.substr(1);
      switch (messageType) {
        case 'm':
          _ref1 = message.split('\t'), number = _ref1[0], userId = _ref1[1], type = _ref1[2], params = _ref1[3];
          params = params ? JSON.parse(params) : {};
          params.clientId = clientId;
          params.userId = userId;
          return gatewayMessage(userId, type, params, (function(body) {
            return send(ws, "<" + number + "\t" + body);
          }), onError);
        case 'i':
          _ref2 = message.split('\t'), number = _ref2[0], clientId = _ref2[1], userId = _ref2[2];
          setClientId(clientId);
          return gatewayMessage(userId, 'init', {
            serverId: serverId,
            clientId: clientId,
            userId: userId
          }, function(body, gatewayServerId) {
            return send(ws, "<" + number + "\t" + gatewayServerId + "\t" + body);
          }, onError);
        case 'u':
          _ref3 = message.split('\t'), number = _ref3[0], updateToken = _ref3[1], userId = _ref3[2], changes = _ref3[3];
          return gatewayMessage(userId, 'update', {
            serverId: serverId,
            updateToken: updateToken,
            clientId: clientId,
            userId: userId,
            changes: changes
          }, function(body) {
            return send(ws, "<" + number + "\t" + body);
          }, onError);
        case 's':
          _ref4 = message.split('\t'), number = _ref4[0], userId = _ref4[1], object = _ref4[2], key = _ref4[3];
          return gatewayMessage(userId, 'subscribe', {
            serverId: serverId,
            clientId: clientId,
            userId: userId,
            object: object,
            key: key
          }, function(body, gatewayServerId) {
            return send(ws, "<" + number + "\t" + gatewayServerId + "\t" + userId + "\t" + object + "\t" + body);
          }, onError);
        case 'z':
          _ref5 = message.split('\t'), number = _ref5[0], userId = _ref5[1], object = _ref5[2];
          return gatewayMessage(userId, 'unsubscribe', {
            serverId: serverId,
            clientId: clientId,
            userId: userId,
            object: object
          }, function(body) {
            return send(ws, "<" + number + "\t" + userId + "\t" + object);
          }, onError);
        case 'r':
          parts = message.split('\t');
          number = parts[0];
          parts = parts.slice(1);
          count = parts.length / 2;
          done = 0;
          r = [];
          _results = [];
          for (i = _i = 0; 0 <= count ? _i < count : _i > count; i = 0 <= count ? ++_i : --_i) {
            userId = parts[i * 2];
            toRetrieve = parts[i * 2 + 1];
            _results.push((function(userId) {
              return gatewayMessage(userId, 'retrieve', {
                serverId: serverId,
                userId: userId,
                clientId: clientId,
                records: toRetrieve
              }, function(body) {
                r.push(userId);
                r.push(body);
                if (++done === count) {
                  return send(ws, "<" + number + "\t" + (r.join('\t')));
                }
              }, onError);
            })(userId));
          }
          return _results;
          break;
        case 't':
          _ref6 = message.split('\t'), userId = _ref6[0], args = 2 <= _ref6.length ? __slice.call(_ref6, 1) : [];
          return gatewayMessage(userId, 'track', {
            serverId: serverId,
            clientId: clientId,
            args: args
          }, function() {}, onError);
        case '$':
          _ref7 = message.split('\t'), commandId = _ref7[0], response = _ref7[1];
          return typeof commandCbs[commandId] === "function" ? commandCbs[commandId](response) : void 0;
        case 'P':
          return console.log("[" + wsNumber + "] ping received " + clientId + " " + message);
      }
    });
  });
};

env.init(function() {
  var count, gatewayServer, id, num, _ref1, _results;
  count = 0;
  num = _.size(env.gatewayServers);
  _ref1 = env.gatewayServers;
  _results = [];
  for (id in _ref1) {
    gatewayServer = _ref1[id];
    _results.push(request({
      url: "http://" + gatewayServer + "/port/started",
      method: 'post',
      form: {
        serverId: serverId
      }
    }, function(error) {
      if (error) {
        addDownServer(id);
      }
      if (++count === num) {
        return start();
      }
    }));
  }
  return _results;
});

//# sourceMappingURL=server.js.map
